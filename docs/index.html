<!doctype html>
<html lang="de">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" id="theme" href="css/theme/league.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" id="syntax" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section id="title-slide">
					<h2 class="fragment">
						Parallel Assignment<br/>
						und<br/>
						Ternäres Konditional<br/>
						in IML
					</h2>
					<p class="fragment">
						<small>von Dominik Landolt<br>und Cyrill Brunner</small>
					</p>
				</section>


				<section id="overview"><h2>Overview</h2></section>


				<section id="overview-parass">
					<h3>Parallel Assignment</h3>
					<section id="overview-parass-1">
						Vorbild Python
						<pre><code class="hljs python" data-trim>
							a, b, c = 1, 2, 3
							print(a, b, c) // "1 2 3"
						</code></pre>
						<div class="fragment">
							IML
							<pre><code class="hljs iml" data-trim>
								// with var a, b, c: int64;
								a init, b init := 1, 2;
								// a = 1, b = 2
								a, b, c init := b, a, a + b;
								// a = 2, b = 1, c = 3
							</code></pre>
						</div>
					</section>
					<section id="overview-parass-2">
						<h4>Anwendungsfälle</h4><br/>
						<ul>
						<li> Kompakte Mehrzuweisung </li>
						<li> Swapping von Variablen </li>
						</ul>
					</section>
				</section>



				<section id="overview-tercon">
					<h3>Ternäres Konditional</h3>
					<section id="overview-tercon-1">
						<pre><code class="hljs iml" data-trim data-noescape>
							// with var a, b, c: int64;
							a init := 12; b init := 20;
							// c mit -1, 0, 1 füllen aufgrund von a &lt;=&gt; b?
							<span class="fragment">
							c init := a &gt; b ? 1 : a &lt; b ? -1 : 0;
							// c = -1
							</span>
						</code></pre>
					</section>

					<section id="overview-tercon-2">
						<h4>Anwendungsfälle</h4><br/>
						<ul>
						<li> Kleine Conditionals </li>
						<li> Simple Rekursion </li>
						</ul>
					</section>
				</section>


				<section id="syntax-title"><h2>Anpassungen der Spezifikation</h2></section>

                <!-- TODO: Nicht abwechselnd, sondern alles pro Feature auf einmal. -->
				<section id="syntax-parass">
					<h3>Parallel Assignment</h3>
					<section id="syntax-parass-1">
						<h4>Lexikalische Syntax</h4>
						<ul class="fragment">
						<li>Unverändert!</li>
						<li><code>:=&nbsp;&nbsp;&rArr;&nbsp;&nbsp;BECOMES</code></li>
						<li><code>,&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;COMMA</code></li>
						</ul>
                        <br>
						<h4 class="fragment">Grammatiksyntax</h4>
						<pre class="fragment"><code class="hljs ebnf" data-trim data-line-numbers="2,9">
							cmd ::= SKIP
								 | exprs BECOMES exprs // expr BECOMES expr
								 | IF expr THEN cpsCmd ELSE cpsCmd ENDIF
								 | WHILE expr DO cpsCmd ENDWHILE
								 | CALL IDENT exprList [globInits]
								 | DEBUGIN expr
								 | DEBUGOUT expr

							exprs ::= expr {COMMA expr}
						</code></pre>
					</section>
				</section>



				<section id="syntax-tercon">
					<h3>Ternäres Konditional</h3>
					<section id="syntax-tercon-1">
						<h4>Lexikalische Syntax</h4>
						<table>
						<tr class="fragment">
							<td>Neu:</td>
							<td><code>?&nbsp;&nbsp;&rArr;&nbsp;&nbsp;CONDOPR</code></td>
						</tr>
						<tr class="fragment">
							<td>Bestehend:</td>
							<td><code>:&nbsp;&nbsp;&rArr;&nbsp;&nbsp;COLON</code></td>
						</tr>
						</table>
					</section>

					<section id="syntax-tercon-2">
						<h4>Grammatiksyntax</h4>
						<pre class="fragment"><code class="hljs ebnf" data-trim data-line-numbers>
							// Expressions:

							expr  ::=  term1 | term1 BOOLOPR expr
							term1 ::=  term2 | term2 RELOPR  term2
							term2 ::=  term3 | term2 ADDOPR  term3
							term3 ::= factor | term3 MULTOPR factor
						</code></pre>
						<pre class="fragment"><code class="hljs ebnf" data-trim data-line-numbers>
							// Expressions:							
							expr  ::=  term1 | term1 CONDOPR expr COLON expr
							term1 ::=  term2 | term2 BOOLOPR term1
							term2 ::=  term3 | term3 RELOPR  term3
							term3 ::=  term4 | term3 ADDOPR  term4
							term4 ::= factor | term4 MULTOPR factor
						</code></pre>
					</section>
				</section>


				<section id="restrictions"><h2>Einschränkungen</h2></section>


				<section id="restrictions-parass">
					<h3>Parallel Assignment</h3>
					<section id="restrictions-parass-1">
						<h4>Typeinschränkungen</h4>
						<ul>
						<li class="fragment">
							Gleiche Zahl und Reihenfolge
							<pre><code class="hljs iml" data-trim>
								// var b1,b2: bool; var i1,i2: int64;
								// all 4 initialized
								b1, i1, i2, b2 := true, 1, 2, false;
							</code></pre>
						</li>
						</ul>
					</section>
				</section>



				<section id="restrictions-tercon">
					<h3>Ternäres Konditional</h3>
					<section id="restrictions-tercon-1">
						<h4>Kontexteinschränkungen</h4>
						<code>rExpr</code>, liefert keine Adresse.
					</section>
					<section id="restrictions-tercon-2">
						<h4>Typeinschränkungen</h4>
						<code>c ? $e_1$ : $e_2$</code><br>
                        <span class="fragment">
                            $$ \frac{\Gamma \vdash c\!: bool,\ e_1\!: \tau, e_2\!: \tau}
                                {\Gamma \vdash (c\ ?\ e_1 : e_2)\!: \tau} $$
                        </span>
                        <ul>
							<li class="fragment"><code>type($c$) == $bool$</code></li>
							<li class="fragment"><code>type($e_1$) == type($e_2$)</code></li>
							<li class="fragment"><code>type($c\ ?\ e_1 : e_2$) == type($e_1$)</code></li>
						</ul>
					</section>
				</section>

				<section id="examples"><h2>Beispiele</h2></section>


				<section id="examples-parass">
					<h3>Parallel Assignment</h3>
					<section id="examples-parass-1">
						<h4>Euklid</h4>
						<pre><code class="hljs iml" data-trim>
                            proc eea(in var a: int64, in var b: int64,
                                     out ggt : int64, out    x: int64, out y: int64)
                            local var x': int64; var y': int64;
                                  var q : int64; var r : int64
                            do if a < b then call eea(b, a, ggt, x, y)
                               else
                                 x init, y init, x' init, y' init,
                                 q init, r init := 1, 0, 0, 1, -1, -1;
                                 while b' /= 0 do
                                   q, r         := a divE b, a modE b;
                                   a, b         := b       , r;
                                   x, y, x', y' := x' , y' , x - q*x', y - q*y'
                                 endwhile;
                                 ggt init := a
                               endif
                            endproc
						</code></pre>
					</section>
				</section>



				<section id="examples-tercon">
					<h3>Ternäres Konditional</h3>
					<section id="examples-tercon-2">
						<h4>Rekursives Faktorial</h4>
						<pre><code class="hljs iml" data-trim>
							fun fact(n: int64)
							  returns m: int64
							do
							  m init := n &lt;= 0 ? 1 : n * fact(n - 1)
							endfun
						</code></pre>
					</section>
				</section>

                <section id="compiler-title"><h2>Compiler</h2></section>

                <section id="parser">
                    <h3>Parser</h3>
                    <section id="parser-1">
                        <h4>Kein Fix & Foxi</h4>
                        <pre class="fragment"><code class="hljs haskell" data-trim>
                            -- | funDecl ::=
                            --         FUN IDENT paramList
                            --         RETURNS stoDecl
                            --         [GLOBAL globImps]
                            --         [LOCAL cpsStoDecl] DO cpsCmd ENDFUN
                            data FunctionDeclaration =
                              FunctionDeclaration Ident [Param]
                                StoreDeclaration [GlobalImport]
                                [StoreDeclaration] [Command]
                              deriving (Eq, Show)
                        </code></pre>
                    </section>
                    <section id="parser-2">
                        <pre><code class="hljs haskell" data-trim>
                            -- | funDecl ::=
                            --         FUN IDENT paramList
                            --         RETURNS stoDecl
                            --         [GLOBAL globImps]
                            --         [LOCAL cpsStoDecl] DO cpsCmd ENDFUN
                            parseFunDecl :: Parser Syntax.FunctionDeclaration
                            parseFunDecl =
                              Syntax.FunctionDeclaration <$>
                              (token T.Fun *> parseIdentifier) <*>
                              parseParamList <*>
                              (token T.Returns *> parseStoDecl) <*>
                              orEmpty (token T.Global *> parseGlobImps) <*>
                              orEmpty (token T.Local *> parseCpsStoDecl) <*>
                              (token T.Do *> parseCpsCmd <* token T.Endfun)
                        </code></pre>
                    </section>
                </section>

                <section id="parser-parass" data-transition="slide">
                    <h3>Parallel Assignment</h3>
                    <section id="parser-parass-1" data-transition="fade">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="1,3">
                            data Command
                              = SkipCommand
                              | AssignCommand Expr Expr
                              | WhileCommand Expr [Command]
                              | CallCommand Ident [Expr] [Ident]
                              | DebugInCommand Expr
                              | DebugOutCommand Expr
                              deriving (Eq, Show)
                        </code></pre>
                    </section>
                    <section id="parser-parass-2" data-transition="fade">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="1,3">
                            data Command
                              = SkipCommand
                              | AssignCommand [Expr] [Expr]
                              | WhileCommand Expr [Command]
                              | CallCommand Ident [Expr] [Ident]
                              | DebugInCommand Expr
                              | DebugOutCommand Expr
                              deriving (Eq, Show)
                        </code></pre>
                    </section>
                    <section id="parser-parass-3" data-transition="fade">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="7" style="font-size: 0.7em;">
                            --
                            --

                            parseCmd :: Parser Syntax.Command
                            parseCmd = _parseSkip <|> _parseBecomes <|> _parseIf <|> _parseWhile <|> _parseCall <|> _parseDebugIn <|> _parseDebugOut
                              where _parseSkip = Syntax.SkipCommand <$ token T.Skip
                                    _parseBecomes = Syntax.AssignCommand <$> parseExpr  <*> (token T.Becomes *> parseExpr )
                                    _parseIf =
                                      Syntax.IfCommand <$> (token T.If *> parseExpr) <*> (token T.Then *> parseCpsCmd) <*>
                                      (token T.Else *> parseCpsCmd <* token T.Endif)
                                    _parseWhile =
                                      Syntax.WhileCommand <$> (token T.While *> parseExpr) <*> (token T.Do *> parseCpsCmd <* token T.Endwhile)
                                    _parseCall = Syntax.CallCommand <$> (token T.Call *> parseIdentifier) <*> parseExprList <*> orEmpty parseGlobInits
                                    _parseDebugIn = Syntax.DebugInCommand <$> (token T.DebugIn *> parseExpr)
                                    _parseDebugOut = Syntax.DebugOutCommand <$> (token T.DebugOut *> parseExpr)
                        </code></pre>
                    </section>
                    <section id="parser-parass-4" data-transition="fade">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="7" style="font-size: 0.7em;">
                            --
                            --

                            parseCmd :: Parser Syntax.Command
                            parseCmd = _parseSkip <|> _parseBecomes <|> _parseIf <|> _parseWhile <|> _parseCall <|> _parseDebugIn <|> _parseDebugOut
                              where _parseSkip = Syntax.SkipCommand <$ token T.Skip
                                    _parseBecomes = Syntax.AssignCommand <$> parseExprs <*> (token T.Becomes *> parseExprs)
                                    _parseIf =
                                      Syntax.IfCommand <$> (token T.If *> parseExpr) <*> (token T.Then *> parseCpsCmd) <*>
                                      (token T.Else *> parseCpsCmd <* token T.Endif)
                                    _parseWhile =
                                      Syntax.WhileCommand <$> (token T.While *> parseExpr) <*> (token T.Do *> parseCpsCmd <* token T.Endwhile)
                                    _parseCall = Syntax.CallCommand <$> (token T.Call *> parseIdentifier) <*> parseExprList <*> orEmpty parseGlobInits
                                    _parseDebugIn = Syntax.DebugInCommand <$> (token T.DebugIn *> parseExpr)
                                    _parseDebugOut = Syntax.DebugOutCommand <$> (token T.DebugOut *> parseExpr)
                        </code></pre>
                    </section>
                    <section id="parser-parass-5" data-transition="fade">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="1-2,7" style="font-size: 0.7em;">
                            parseExprs :: Parser [Syntax.Expr]
                            parseExprs = commaList parseExpr

                            parseCmd :: Parser Syntax.Command
                            parseCmd = _parseSkip <|> _parseBecomes <|> _parseIf <|> _parseWhile <|> _parseCall <|> _parseDebugIn <|> _parseDebugOut
                              where _parseSkip = Syntax.SkipCommand <$ token T.Skip
                                    _parseBecomes = Syntax.AssignCommand <$> parseExprs <*> (token T.Becomes *> parseExprs)
                                    _parseIf =
                                      Syntax.IfCommand <$> (token T.If *> parseExpr) <*> (token T.Then *> parseCpsCmd) <*>
                                      (token T.Else *> parseCpsCmd <* token T.Endif)
                                    _parseWhile =
                                      Syntax.WhileCommand <$> (token T.While *> parseExpr) <*> (token T.Do *> parseCpsCmd <* token T.Endwhile)
                                    _parseCall = Syntax.CallCommand <$> (token T.Call *> parseIdentifier) <*> parseExprList <*> orEmpty parseGlobInits
                                    _parseDebugIn = Syntax.DebugInCommand <$> (token T.DebugIn *> parseExpr)
                                    _parseDebugOut = Syntax.DebugOutCommand <$> (token T.DebugOut *> parseExpr)
                        </code></pre>
                    </section>
                </section>

                <section id="parser-tercon" data-transition="slide">
                    <h3>Ternäres Konditional</h3>
                    <section id="parser-tercon-1" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="7">
                            data Expr
                              = LiteralExpr AtomicType Literal
                              | FunctionCallExpr AtomicType Ident [Expr]
                              | NameExpr AtomicType Ident Bool -- Variable names, bool = init or not
                              | UnaryExpr AtomicType UnaryOpr Expr
                              | BinaryExpr AtomicType BinaryOpr Expr Expr
                              | ConditionalExpr AtomicType Expr Expr Expr
                              deriving (Eq, Show)
                        </code></pre>
                    </section>
                    <section id="parser-tercon-2" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="1,2" style="font-size: 0.75em;">
                            -- | expr  ::=
                            --         term1 [CONDOPR expr COLON expr]
                            parseExpr :: Parser Syntax.Expr
                            parseExpr = do


                                Nothing -> condition
                                Just (trueValue, falseValue) ->
                                  (Syntax.ConditionalExpr Syntax.Untyped condition trueValue falseValue))
                              where
                                _parseRest =
                                    (,) <$>
                                    --
                                    --
                        </code></pre>
                    </section>
                    <section id="parser-tercon-3" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="1,2,5" style="font-size: 0.75em;">
                            -- | expr  ::=
                            --         term1 [CONDOPR expr COLON expr]
                            parseExpr :: Parser Syntax.Expr
                            parseExpr = do
                              condition <- parseTerm1

                                Nothing -> condition
                                Just (trueValue, falseValue) ->
                                  (Syntax.ConditionalExpr Syntax.Untyped condition trueValue falseValue))
                              where
                                _parseRest =
                                    (,) <$>
                                    --
                                    --
                        </code></pre>
                    </section>
                    <section id="parser-tercon-4" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="1,2,5,6" style="font-size: 0.75em;">
                            -- | expr  ::=
                            --         term1 [CONDOPR expr COLON expr]
                            parseExpr :: Parser Syntax.Expr
                            parseExpr = do
                              condition <- parseTerm1
                              optional _parseRest <&> \case
                                Nothing -> condition
                                Just (trueValue, falseValue) ->
                                  (Syntax.ConditionalExpr Syntax.Untyped condition trueValue falseValue))
                              where
                                _parseRest =
                                    (,) <$>
                                    --
                                    --
                        </code></pre>
                    </section>
                    <section id="parser-tercon-5" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="1,2,5,6,13" style="font-size: 0.75em;">
                            -- | expr  ::=
                            --         term1 [CONDOPR expr COLON expr]
                            parseExpr :: Parser Syntax.Expr
                            parseExpr = do
                              condition <- parseTerm1
                              optional _parseRest <&> \case
                                Nothing -> condition
                                Just (trueValue, falseValue) ->
                                  (Syntax.ConditionalExpr Syntax.Untyped condition trueValue falseValue))
                              where
                                _parseRest =
                                    (,) <$>
                                    (token T.CondOpr *> parseExpr) <*>
                                    --
                        </code></pre>
                    </section>
                    <section id="parser-tercon-6" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="1,2,5,6,13,14" style="font-size: 0.75em;">
                            -- | expr  ::=
                            --         term1 [CONDOPR expr COLON expr]
                            parseExpr :: Parser Syntax.Expr
                            parseExpr = do
                              condition <- parseTerm1
                              optional _parseRest <&> \case
                                Nothing -> condition
                                Just (trueValue, falseValue) ->
                                  (Syntax.ConditionalExpr Syntax.Untyped condition trueValue falseValue))
                              where
                                _parseRest =
                                    (,) <$>
                                    (token T.CondOpr *> parseExpr) <*>
                                    (token T.Colon *> parseExpr)
                        </code></pre>
                    </section>
                </section>



                <section id="typecheck-title"><h2>Typechecker</h2></section>

                <section id="typecheck-parass" data-transition="slide">
                    <h3>Parallel Assignment</h3>
                    <section id="typecheck-parass-1" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers style="font-size: 0.75em;">
                            (S.AssignCommand exprl1 exprl2) ->
                              if checked
                                then S.AssignCommand newExprl1 newExprl2
                                else error "Type Error: AssignCommand"
                              where newExprl1 = checkExpr c exprl1
                                    newExprl2 = checkExpr c exprl2
                                    checked   =
                                      and (zipWith
                                            (\e1 e2 ->
                                              (getExprAtomicType e1 == getExprAtomicType e2) &&
                                              (isLExpr e1) ||
                                              error "Assingment of two differnt types")
                                            newExprl1
                                            newExprl2)
                        </code></pre>
                    </section>
                </section>

                <section id="typecheck-tercon" data-transition="slide">
                    <h3>Ternäres Konditional</h3>
                    <section id="typecheck-tercon-1" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers="10-12" style="font-size: 0.75em;">
                            (S.ConditionalExpr atomicType expr1 expr2 expr3) ->
                              if isBoolType
                                then if equal
                                       then S.ConditionalExpr ty nex1 nex2 nex3
                                       else error "Type Error: Conditional do not support different branching types."
                                else error "Type Error: Conditional must have bool type as condition."
                              where nex1 = checkExprSingle c expr1
                                    nex2 = checkExprSingle c expr2
                                    nex3 = checkExprSingle c expr3
                                    isBoolType = getExprAtomicType nex1 == S.BoolType
                                    ty = getExprAtomicType nex2
                                    equal = ty == getExprAtomicType nex3
                        </code></pre>
                    </section>
                </section>



                <section id="codegen-title"><h2>CodeGen</h2></section>
                <section id="codegen-parass" data-transition="slide">
                    <h3>Parallel Assignment</h3>
                    <section id="codegen-parass-1" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers style="font-size: 0.75em;">
                            compileAssignment ::  S.Expr  ->  S.Expr  -> Scoped [UnfixedInstruction]
                            compileAssignment leftExpr  rightExpr  = do
                              rightInstrs <-      compileExpr rightExpr
                              leftLoad  <-      compileLExpr leftExpr










                              return $ leftLoad ++ rightInstrs ++ [FixedInstruction VM.Store]
                        </code></pre>
                    </section>
                    <section id="codegen-parass-2" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers style="font-size: 0.75em;">
                            compileAssignment :: [S.Expr] -> [S.Expr] -> Scoped [UnfixedInstruction]
                            compileAssignment leftExprs rightExprs = do
                              rightInstrs <- mapM compileExpr rightExprs
                              leftLoads <- mapM compileLExpr leftExprs
                              tempOffset <- asks $ tempSlotStart . activeSlotMap
                              let frameTempLoadAddrs = FixedInstruction . VM.LoadAddrRel <$> [tempOffset ..]
                                  computeInstructions =
                                    zipWith
                                      (\rhi tLoad -> tLoad : rhi ++ [FixedInstruction VM.Store])
                                      rightInstrs frameTempLoadAddrs
                                  storeInstructions =
                                    zipWith
                                      (\load tempAddrLoad -> load ++ [tempAddrLoad, FixedInstruction VM.Deref, FixedInstruction VM.Store])
                                      leftLoads frameTempLoadAddrs
                              return $ concat $ computeInstructions ++ storeInstructions
                        </code></pre>
                    </section>
                </section>

                <section id="codegen-tercon" data-transition="slide">
                    <h3>Ternäres Konditional</h3>
                    <section id="codegen-tercon-1" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers style="font-size: 0.75em;">
                            compileIf   ::           S.Expr -> [S.Command] -> [S.Command] -> Scoped [UInstruction]
                            compileIf     condition thenBlock elseBlock = do
                              conditionInstructions <- compileExpr condition
                              thenInstructions <- foldMapM compileCommand thenBlock
                              elseInstructions <- foldMapM compileCommand elseBlock
                              let skipThenInstruction = RelativeCondJump $ length thenInstructions + 2
                                  skipElseInstruction = RelativeUncondJump $ length elseInstructions + 1
                              return $
                                conditionInstructions ++ skipThenInstruction :
                                  thenInstructions ++ skipElseInstruction :
                                  elseInstructions
                        </code></pre>
                    </section>
                    <section id="codegen-tercon-2" data-transition="none">
                        <pre><code class="hljs haskell" data-trim data-line-numbers style="font-size: 0.75em;">
                            compileCond :: S.Type -> S.Expr ->  S.Expr     ->  S.Expr     -> Scoped [UInstruction]
                            compileCond _ condition thenExpr  elseExpr  = do
                              conditionInstructions <- compileExpr condition
                              thenInstructions <-          compileExpr    thenExpr
                              elseInstructions <-          compileExpr    elseExpr
                              let skipThenInstruction = RelativeCondJump $ length thenInstructions + 2
                                  skipElseInstruction = RelativeUncondJump $ length elseInstructions + 1
                              return $
                                conditionInstructions ++ skipThenInstruction :
                                  thenInstructions ++ skipElseInstruction :
                                  elseInstructions
                        </code></pre>
                    </section>
                </section>



                <section id="end-slide">
                    <h3>Danke!</h3>
                </section>
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			function imlLang(hljs) {
				let identRegex = "[a-zA-Z]([a-zA-Z]|[0-9]|'|_)*";
                return {
                    case_insensitive: false,
                    keywords: {
                        keyword: 'call const copy debugin debugout divE do else endfun endif endproc endprogram endwhile false fun global if in init inout local modE not out proc program ref returns skip then true var while',
                        literal: 'true false',
                        built_in: 'bool int64'
                    },
                    lexemes: identRegex,
                    contains: [
                        hljs.C_LINE_COMMENT_MODE,
                        {className: 'number', begin: "\\b[0-9]+('*[0-9]+)*"},
                        {
                            variants: [
                                {className: 'function', beginKeywords: 'proc fun'}
                            ],
                            end: /\(/,
                            contains: [{className: 'title', begin: identRegex}]
                        }
                    ]
                };
			}

			function ebnfLang(hljs) {
				let nonTerminal = {
					className: "attribute",
					begin: /[a-z][A-Za-z0-9]*\b/
				};

				let terminal = {
					className: "symbol",
					begin: /[A-Z]+\b/
				};

                return {
                    case_insensitive: false,
                    contains: [
                        hljs.C_LINE_COMMENT_MODE,
                        nonTerminal,
                        terminal
                    ]
                };
			}

			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				autoPlayMedia: true,
				highlight: {
					highlightOnLoad: false
				},

				slideNumber: 'h/t',
				transition: 'slide', // none/fade/slide/convex/concave/zoom

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/math/math.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback() {
						hljs.configure({languages: []}); // Disable detection.
						hljs.registerLanguage('iml', imlLang);
						hljs.registerLanguage('ebnf', ebnfLang);
						// hljs.initHighlightingOnLoad();

						Reveal.getConfig().highlight.highlightOnLoad = true;
						Reveal.getPlugin("highlight").init()
					}}
				]
			});
		</script>
	</body>
</html>
